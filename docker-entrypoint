#!/bin/bash

if [[ "$DEBUG" = "1" ]]; then
  set -x
  BASH_CMD_FLAGS='-x'
fi

# Functions
__validations() {
  # Check if AWS R53 variables are declared.
  if [[ "$AWS_ACCESS_KEY_ID" == "" ]]; then
    printf "| ENTRYPOINT: ${RED}AWS_ACCESS_KEY_ID/AWS_ACCESS_KEY_ID_FILE ";
    printf "variable is not declared${NC}\n";
    sleep 120 # To avoid to frequent service restarts
    exit 1
  fi

  if [[ "$AWS_SECRET_ACCESS_KEY" == "" ]]; then
    printf "| ENTRYPOINT: ${RED}AWS_SECRET_ACCESS_KEY/";
    printf "AWS_SECRET_ACCESS_KEY_FILE variable is not declared${NC}\n";
    sleep 120 # To avoid to frequent service restarts
    exit 1
  fi

  if [[ "$AWS_HOSTED_ZONE_ID" == "" ]]; then
    printf "| ENTRYPOINT: ${RED}AWS_HOSTED_ZONE_ID/";
    printf "AWS_HOSTED_ZONE_ID_FILE variable is not declared${NC}\n";
    sleep 120 # To avoid to frequent service restarts
    exit 1
  fi

  if [[ "$AWS_REGION" == "" ]]; then
    export AWS_REGION=us-east-1
    printf "| ENTRYPOINT: ${YELLOW}AWS_REGION ";
    printf "variable is not declared, using '${AWS_REGION}' as default${NC}\n";
  fi

  if [ -z $CERTBOT_EMAIL ]; then
    printf "| ENTRYPOINT: ${RED}CERTBOT_EMAIL ";
    printf "variable is not declared${NC}\n";
    sleep 120 # To avoid to frequent service restarts
    exit 1
  fi

  if [[ "$PROXY_PORT" == "" ]]; then
    export PROXY_PORT=8080
    printf "| ENTRYPOINT: ${YELLOW}PROXY_PORT ";
    printf "variable is not declared, using '${PROXY_PORT}' as default${NC}\n";
  fi

  if [[ "$PROXY_ADDRESS" == "" ]]; then
    export PROXY_ADDRESS=proxy
    printf "| ENTRYPOINT: ${YELLOW}PROXY_ADDRESS ";
    printf "variable is not declared, using '${PROXY_ADDRESS}' as default${NC}\n";
  fi
}

__loadSecrets() {
  # Load env vars
  printf "| ENTRYPOINT: ${RED}Loading docker secrets if exists...${NC}\n";
  for i in $(env|grep '/run/secrets')
  do
      varName=$(echo $i|awk -F '[=]' '{print $1}'|sed 's/_FILE//')
      varFile=$(echo $i|awk -F '[=]' '{print $2}')
      exportCmd="export $varName=$(cat $varFile)"
      printf "| ENTRYPOINT: Exporting var: $varName\n";
      eval "${exportCmd}"
  done
}

__checkCertmgrMode() {
  # Disable certbot if CERTBOT_DISABLE is defined
  if [[ "$CERTMGR_DISABLE" == "" ]]; then
    printf "| ENTRYPOINT: ${RED}Certificate manager is enabled.${NC}\n";
  else
    printf "| ENTRYPOINT: ${RED}CERTMGR_DISABLE variable is declared, \n";
    printf "|             ${RED}To avoid container relaunches, ";
    printf "i will sleep forever${NC}\n";
    printf "| ENTRYPOINT: ${YELLOW}To enable certificate management,${NC}\n";
    printf "|             ${YELLOW}please remove CERTMGR_DISABLE env${NC}\n";
    printf "|             ${YELLOW}variable arg from docker run cmd${NC}\n";
    printf "|             ${YELLOW}or stack and start again${NC}\n";
    # Set container status to healthy to avoid service restarts when intention
    # was to just disable certificate manager
    while true; do sleep 10000; done
  fi
}

__printLine() {
  printf "|----------------------------------------------------------------\n";
}

## Main

# Colors
export RED='\033[1m\033[31m'
export GREEN='\033[1m\033[32m'
export YELLOW='\033[1m\033[33m'
export MAGENTA='\033[1m\033[35m'
export CYAN='\033[1m\033[36m'
export NC='\033[0m' # No Color

# Start with healthy state

__printLine
printf "| ENTRYPOINT: Starting Docker Flow - Let's Encrypt\n"
__printLine
__loadSecrets
__validations
__checkCertmgrMode
__printLine

# Check if app-config is present
if [ -f /app-config ]; then
    # We expect that app-config handles the launch of app command
    printf "| ENTRYPOINT: Executing app-config...\n";
    . /app-config "$@"
else
    # Let default CMD run if app-config is missing
    printf "| ENTRYPOINT: Custom script app-config was not available\n";
    printf "| ENTRYPOINT: Executing given parameters or default CMD\n";
    exec $@
fi
